"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const abi_1 = require("@ethersproject/abi");
const delete_empty_1 = __importDefault(require("delete-empty"));
const fs_1 = __importDefault(require("fs"));
const config_1 = require("hardhat/config");
const path_1 = __importDefault(require("path"));
const readdirRecursive = (dirPath, output = []) => {
    const files = fs_1.default.readdirSync(dirPath);
    files.forEach((file) => {
        file = path_1.default.join(dirPath, file);
        if (fs_1.default.statSync(file).isDirectory()) {
            output = readdirRecursive(file, output);
        }
        else {
            output.push(file);
        }
    });
    return output;
};
(0, config_1.task)('clear-abi', async (args, hre) => {
    const configs = hre.config.abiExporter;
    await Promise.all(configs.map((abiExporterConfig) => {
        return hre.run('clear-abi-group', { path: abiExporterConfig.path });
    }));
});
(0, config_1.subtask)('clear-abi-group')
    .addParam('path', 'path to look for ABIs', undefined, config_1.types.string)
    .setAction(async (args, hre) => {
    const outputDirectory = path_1.default.resolve(hre.config.paths.root, args.path);
    if (!fs_1.default.existsSync(outputDirectory)) {
        return;
    }
    const files = readdirRecursive(outputDirectory);
    await Promise.all(files.map(async (file) => {
        if (path_1.default.extname(file) !== '.json') {
            // ABIs must be stored as JSON
            return;
        }
        const contents = await fs_1.default.promises.readFile(file);
        try {
            // attempt to parse ABI from file contents
            new abi_1.Interface(contents.toString());
        }
        catch (e) {
            // file is not an ABI - do not delete
            return;
        }
        await fs_1.default.promises.rm(file);
    }));
    await (0, delete_empty_1.default)(outputDirectory);
});
