"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const package_json_1 = require("../../package.json");
const abi_1 = require("@ethersproject/abi");
const fs_1 = __importDefault(require("fs"));
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const path_1 = __importDefault(require("path"));
(0, config_1.task)('export-abi')
    .addFlag('noCompile', "Don't compile before running this task")
    .setAction(async (args, hre) => {
    if (!args.noCompile) {
        await hre.run(task_names_1.TASK_COMPILE, { noExportAbi: true });
    }
    const configs = hre.config.abiExporter;
    await Promise.all(configs.map((abiGroupConfig) => {
        return hre.run('export-abi-group', { abiGroupConfig });
    }));
});
(0, config_1.subtask)('export-abi-group')
    .addParam('abiGroupConfig', 'a single abi-exporter config object', undefined, config_1.types.any)
    .setAction(async (args, hre) => {
    const { abiGroupConfig: config } = args;
    const outputDirectory = path_1.default.resolve(hre.config.paths.root, config.path);
    if (outputDirectory === hre.config.paths.root) {
        throw new plugins_1.HardhatPluginError(package_json_1.name, 'resolved path must not be root directory');
    }
    const outputData = [];
    const fullNames = await hre.artifacts.getAllFullyQualifiedNames();
    await Promise.all(fullNames.map(async (fullName) => {
        if (config.only.length && !config.only.some((m) => fullName.match(m)))
            return;
        if (config.except.length &&
            config.except.some((m) => fullName.match(m)))
            return;
        let { abi, sourceName, contractName } = await hre.artifacts.readArtifact(fullName);
        if (!abi.length)
            return;
        abi = abi.filter((element, index, array) => config.filter(element, index, array, fullName));
        if (config.format == 'minimal') {
            abi = [new abi_1.Interface(abi).format(abi_1.FormatTypes.minimal)].flat();
        }
        else if (config.format == 'fullName') {
            abi = [new abi_1.Interface(abi).format(abi_1.FormatTypes.fullName)].flat();
        }
        else if (config.format != 'json') {
            throw new plugins_1.HardhatPluginError(package_json_1.name, `Unknown format: ${config.format}`);
        }
        const destination = path_1.default.resolve(outputDirectory, config.rename(sourceName, contractName)) + '.json';
        outputData.push({ abi, destination });
    }));
    outputData.reduce((acc, { abi, destination }) => {
        const contents = acc[destination];
        if (contents && JSON.stringify(contents) !== JSON.stringify(abi)) {
            throw new plugins_1.HardhatPluginError(package_json_1.name, `multiple distinct contracts share same output destination: ${destination}`);
        }
        acc[destination] = abi;
        return acc;
    }, {});
    if (config.clear) {
        await hre.run('clear-abi-group', { path: config.path });
    }
    await Promise.all(outputData.map(async ({ abi, destination }) => {
        await fs_1.default.promises.mkdir(path_1.default.dirname(destination), { recursive: true });
        await fs_1.default.promises.writeFile(destination, `${JSON.stringify(abi, null, config.spacing)}\n`, { flag: 'w' });
    }));
});
